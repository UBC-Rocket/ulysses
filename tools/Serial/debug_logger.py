#!/usr/bin/env python3
"""
Simple serial logger for capturing debug output from the flight software.

Features:
  * Cross-platform default port detection.
  * JSON-lines output with ISO timestamps for easy post-processing.
  * Unique log filenames that include a timestamp so sessions never collide.
"""

from __future__ import annotations

import argparse
import dataclasses
import datetime as dt
import json
import os
import sys
from pathlib import Path
from typing import Iterator, Optional

try:
    import serial  # type: ignore
    from serial import SerialException  # type: ignore
except ImportError as exc:  # pragma: no cover - dependency issue
    print(
        "pyserial is required (pip install pyserial).",
        file=sys.stderr,
    )
    raise


DEFAULT_BAUD = 115_200
UNIX_DEFAULT_PORT = "/dev/tty.usbmodem102"
WINDOWS_DEFAULT_PORT = "COM3"
SCRIPT_DIR = Path(__file__).resolve().parent


@dataclasses.dataclass
class SerialRecord:
    """
    Structured log entry for each serial payload received.
    """

    timestamp: str
    payload: str

    def to_json(self) -> str:
        return json.dumps(dataclasses.asdict(self), ensure_ascii=False)


def default_port() -> str:
    if os.name == "nt":
        return WINDOWS_DEFAULT_PORT
    return UNIX_DEFAULT_PORT


def unique_log_path(prefix: str = "debug_log", directory: Path | None = None) -> Path:
    timestamp = dt.datetime.now(dt.timezone.utc).strftime("%Y%m%d_%H%M%S")
    directory = directory or (SCRIPT_DIR / "logs")
    directory.mkdir(parents=True, exist_ok=True)
    return directory / f"{prefix}_{timestamp}.jsonl"


def serial_lines(
    ser: serial.Serial,
    chunk_size: int = 256,
) -> Iterator[str]:
    """
    Yield newline-delimited strings from the serial stream.
    """
    buffer = bytearray()
    while True:
        data = ser.read(chunk_size)
        if not data:
            continue
        buffer.extend(data)
        while b"\n" in buffer:
            line, _, buffer = buffer.partition(b"\n")
            yield line.decode(errors="replace").rstrip("\r")


def write_records(port: str, baud: int, output: Path) -> None:
    print(f"Opening {port} @ {baud} baud …")
    try:
        with serial.Serial(port, baud, timeout=0.1) as ser, output.open(
            "w", encoding="utf-8"
        ) as logfile:
            print(f"Logging to {output}")
            for line in serial_lines(ser):
                record = SerialRecord(
                    timestamp=dt.datetime.now(dt.timezone.utc).isoformat(),
                    payload=line,
                )
                logfile.write(record.to_json() + "\n")
                logfile.flush()
                print(line)
    except SerialException as exc:
        print(f"Serial error: {exc}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nStop signal received, closing log …")
    finally:
        print(f"Log saved to {output}")


def parse_args(argv: Optional[list[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Serial debug logger")
    parser.add_argument(
        "-p",
        "--port",
        default=default_port(),
        help=f"Serial port (default: %(default)s)",
    )
    parser.add_argument(
        "-b",
        "--baud",
        type=int,
        default=DEFAULT_BAUD,
        help="Baud rate (default: %(default)s)",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        default=None,
        help="Optional output file path. Defaults to timestamped file in ./logs/",
    )
    parser.add_argument(
        "--log-dir",
        type=Path,
        default=SCRIPT_DIR / "logs",
        help="Directory for autogenerated logs (default: %(default)s)",
    )
    return parser.parse_args(argv)


def main(argv: Optional[list[str]] = None) -> None:
    args = parse_args(argv)
    output_path = args.output or unique_log_path(directory=args.log_dir)
    write_records(args.port, args.baud, output_path)


if __name__ == "__main__":
    main()
